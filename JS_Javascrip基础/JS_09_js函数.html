<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        // 声明函数
        var test = function app01(x,y){
            alert(x*y)
        }
        // 调用函数
        test(10, 20)

        // 参数匹配
        function app02(num1, num2){
            console.log(num1 + num2)
        }
            // 1. 实参 形参 一对一匹配
            app02(10,20) // 30
            // 2. 实参 多于 形参, 会取到形参的个数
            app02(10,20,30) // 30
            // 3. 实参 少于 形参, 多于的形参定义为undefined 结果为 NaN
            app02(10) // NaN

        // return
        function app03(num1,num2){
            return num1*num2
        }
        var test02 = app03(10, 20)
        console.log(test02);

        // 求最大值
        function getArrayMax(params) {
            var temp = 0;
            for(var i = 0; i < params.length; i++){
                if(params[i] > temp){
                    temp = params[i]
                }
            }
            return temp
        }
        alert(getArrayMax([1,6,3,2,6,8,9,54,2,4,4323,4,3,54,23]))

        // arguments

            // 伪数组 并不是真正意义上的数组
            // (1) 具有数组的 length 属性
            // (2) 按照索引的方式进行存储
            // (3) 并没有真正数组的一些方法
        function fn(){
            console.log(arguments); // 1, 2, 3
            console.log(arguments.length); // 3
            console.log(arguments[1]); // 2

            var getMax = arguments[0];
            for(var i = 0; i < arguments.length; i++){
                if(arguments[i] > getMax){
                    getMax = arguments[i]
                }
            }
            console.log(getMax);
        }
        fn(1,2,3.4,2,3,4,5,4,3,4,3,2,3,2,8,7,56,99,6,3,4,5)


        // 函数嵌套
        function fn1(){
            console.log('hello')
        }
        function fn2(){
            console.log('world');
            fn1()
        }
        fn2()
            // 案列

            function juge2(cyear){
                var flag = false;
                if(cyear % 4 == 0 && cyear % 100 != 0 || cyear % 400 == 0){
                    flag = true;
                }
                return flag
            }
            function backDay(){
                var year = prompt('年份')
                return juge2(year)
            }
            console.log(backDay());

        // 作用域
        var app04 = 10;
        console.log(app04); // 全局变量   存在内存中  耗费资源

        var app05 = function() {
            test08 = 100;   // 全局变量 没有用var 声明
            var test05 = 10;// 局部变量 在函数内部使用, 函数使用完毕就会自动销毁
        }
        console.log(app05());

        // 作用域链
            // 内部函数访问外部函数的变量, 采取的是 链式查找 的方式来决定取哪个值
        var test06 = 10;
        function fnc(){
            var test06 = 15;
            function fnc2(){
                console.log(test06);
            }
        }
        fnc()

    </script>
</head>
<body>
    <!-- 函数 -->
        <!-- 就是封装了一段可以被重复调用执行的代码块。通过此代码块可以实现大量代码的重复使用 -->
        <!-- 
            语法：
            function 函数名(形参1, 形参2, ...) {
                函数体
            }
            函数名(实参1, 实参2, ....)
            (1). function 声明函数的关键字 全部小写
            (2). 函数是做某件事情，函数名一般是动词 sayHi
            (3). 函数不调用自己不执行
            (4). 调用函数必须加 小括号()
            (5). 函数的参数可以有 可以没有
         -->
        <!-- 参数匹配 -->
            <!-- 
                (1)实参 等于 形参 : 一 一 对应传递
                (2)实参 多于 形参 : 取到形参个数
                (3)实参 少于 形参 : 多于形参undefined,结果NaN
             -->

        <!-- return语句 -->
             <!-- 
                 语法: 
                function 函数名(形参1, 形参2, ...) {
                            函数体
                            return 需要返回的结果
                }
                函数名(实参1, 实参2, ....)
            -->
            <!-- 
                (1) 函数只是实现某种功能, 最终的结果需要返回给函数的调用者 函数名() 通过 return实现
                (2) 只要函数遇到 return 就会把后面的结果 返回给函数的调用者 函数名() = return后面的结果
                (3) return 可以直接终止函数
                (4) return 一次只能返回 1 个值
                (5) 函数没有return 返回 undefined
             -->
    <!-- arguments -->
        <!-- 用来传递不确定长的参数 -->

    <!-- 函数的两种声明方式 -->
            <!-- 1. 命名函数:  function 函数名() {} -->
            <!-- 
                 2. 匿名函数:  var 变量名 = function() {}  
                 调用: 变量名() 
            -->

    <!-- 作用域 -->
        <!-- 限定变量名字的可用性的代码范围就称为作用域 -->

            <!-- 全局作用域: 整个script标签, 或一个单独的js文件 -->
            <!-- 局部作用域: 只在函数内部起效果的变量 -->

            <!-- 如果在函数内部 没有 var 声明, 直接赋值的变量 也为全局变量 -->

    <!-- 作用域链 -->

    <!-- 预解析 -->
        <!-- 
            1.js执行代码分为 预解析 和 代码执行
                (1) 预解析js引擎会把js里面所有的var 还有 function 提升到当前作用域的最前面
                (2) 代码执行 按照代码书写的顺序从上往下执行
                
            2.预解析分为 变量预解析（变量提升）和 函数解析（函数提升）
                (1) 变量提升 就是把所有的变量声明提升到当前的作用域最前面 不提升赋值操作
         -->

    
</body>
</html>